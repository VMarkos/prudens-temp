<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="style_1.css" media="screen"/>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
        <!-- <script type="text/javascript" src="parsers.js"></script>
        <script type="text/javascript" src="utils.js"></script>
        <script type="text/javascript" src="prudensUtils.js"></script>
        <script type="text/javascript" src="prudens.js"></script>
        <script type="text/javascript" src="abduction.js"></script> -->
        <title>
            Prudens
        </title>
    </head>
    <body>
        <div class="navbar-container">
            <div class="navbar-centering-container">
                <div class="hamburger-menu-container" onclick="burgerMenuDrop()">
                    <i id="menu-burger" class="fa fa-bars fa-2x"></i>
                </div>
                <div class="navbar-logo-container">
                    <a href="index.html">Prudens</a>
                </div>
                <div class="social-icons-container">
                    <a href="https://github.com/VMarkos/prudens-js"><i class="fa fa-github fa-2x"></i></a>
                </div>
            </div>
        </div>
        <div id="hamburger-menu" class="hamburger-menu hidden">
            <div class="menu-options-container">
                <div id="menu-options-container" class="menu-options-left-align">
                    <div class="menu-option">
                        <a href="index.html"><span><i class="fa fa-home"></i> Home</span></a>
                    </div>
                    <div class="menu-option">
                        <a href="prudens_web.html"><span><i class="fa fa-window-maximize"></i> Prudens Web</span></a>
                    </div>
                    <div class="menu-option">
                        <a href="prudens_api.html"><span><i class="fa fa-gears"></i> Prudens API</span></a>
                    </div>
                    <div class="menu-option">
                        <a href="docs.html"><span><i class="fa fa-book"></i> Learn Prudens</span></a>
                    </div>
                    <div class="menu-option">
                        <a href="research.html"><span><i class="fa fa-flask"></i> Research</span></a>
                    </div>
                </div>
            </div>
        </div>
        <div class="main-docs-container">
            <!-- <div class="cards-grid"> -->
                <div id="main-container" class="card-container no-animation">
                    <div class="docs-grid-container">
                    	<div class="toc-container">
                            <h2>Contents</h2>
                    		<ul id="toc">
                    		</ul>
                    	</div>
                    	<div class="docs-text-container">
                            <div>
                                <h2>About Machine Coaching</h2>
                                <p>
                                    Since you are viewing this page, you 
                                	are probably already accustomed, up to some extent, with several applications of Artificial
                                	Intelligence (AI, for short): machine translation, image or voice recognition, home assistants, all
                                	these applications are fueled by so-called Machine Learning. But, as you may have already experienced,
                                	most of the above solutions severly lack in terms of <b>transparency</b>. How can a computer 
                                	recognize cats in YouTube videos? Why did your smart assistant take some certain action?
                                </p>
                            	<p>
                                    Usually, all such agents are trained on tons of relevant data and, implicitly, detect correlations
                                    among them that, eventually, lead to a behavior often suprassing human efficiency. However, as you
                                    may have already realized, all this comes at a cost: <b>comprehensibility</b>. <i>Machine Coaching</i> 
                                    proposes a more clear and human-friendly way of training machines to do several tasks for us. Let us 
                                    consider a simple scenario, where we want to teach to a machine how to handle our calls. Actually, let's
                                    assume that we provide the following piece of advice to our machine:
                            	</p>
                            	<p>
                            		<i>"Do not answer any calls from work on weekends!"</i>
                            	</p>
                            	<p>
                                    Simple as that! We asked (well, actually, we demanded) our machine to decline any incoming calls from 
                            	    colleagues or anyone related to our work. Let's not focus on the interface that facilitates this interaction between us and our machine; we have
                            	    devised some sophisticated way to communicate with it. Given that, the above is a nice and meaningful piece of advice.
                            	</p>
                                <p>
                                    For some time, we are highly satisfied with the behavior of our "smart" assistance: it behaves exactly as we have
                                    wished to, not allowing any work-related issues to distract us from our precious weekends. However, a really 
                                    important deadline next Monday means that we might need to have some heated meatings with our co-workers. For this 
                                    prupose, we will need to inform our machine about a minor change in its policy:
                                </p>
                                <p>
                                    <i>"Answer all calls in case I have an upcoming deadline!"</i>
                                </p>
                                <p>
                                    Thus, we have introduced an <b>exception</b> to our policy. Namely, we have allowed our assistant to deviate from its 
                                    "do not disturb me on weekends" behavior and allow some calls under some certain <i>circumstances</i>. In a similar
                                    fashion, we can introduce at any time more and more exceptions and, eventually, have our assistant behave as if it was us.
                                </p>
                                <p>
                                    The above human-machine interaction protocol is a simple case of <i>Machine Coaching</i>.
                                    For more on Machine Coaching and its formal description, see <a href="https://cognition.ouc.ac.cy/loizos/papers/Michael_2019_MachineCoaching.pdf">this paper</a>.
                                </p>
                            </div>
                            <div>
                                <h2>Prudens Syntax</h2>
                                <p>
                                    All human-machine interaction within the scope of Machine Coaching is conducted through
                                    Prudens's language. Below we shall describe this language's syntax, providing relevant 
                                    examples when necessary. We shall not delve into details on what each of the constructs 
                                    presented below represent. For more on this, you may consult the "Reasoning" section.
                                </p>
                                <h3>Atoms & Literals</h3>
                                <p>
									Atoms are expressions of one of the following forms:
                                </p>
                                <ul>
									<li><code>name</code></li>
									<li><code>name(arg1, arg2,..., argN)</code></li>
                                </ul>
                                <p>
									Atoms of the first kind are called <i>propositional</i> while those of the second kind are
									called <i>relational</i> or, more often, <i>predicates</i>. In any case, <code>name</code> may be any string such that:
								</p>
                                <ul>
									<li>it starts with a lowercase letter of the latin alphabet;</li>
									<li>it contains only alphanumeric characters (a-z, A-Z, 0-9) and/or underscores.</li>
                                </ul>
                                <p>
									Regarding a predicate's arguments, they may be of any of the following forms:
									</p>
                                <ul>
									<li>a string starting with a lowercase letter (a-z), containing any number of
									alphanumeric characters and/or underscores or;</li>
									<li>a string starting with an uppercase letter (A-Z), containing any number of
									alphanumeric characters and/or underscores or.</li>
                                </ul>
                                <p>
									Arguments of the first type are called <i>constants</i>, while those of the second are
									called <i>variables</i>. Note that a predicate's arguments, in case there are more
									than one, are comma-separated.
                                </p>
                                <p>
									Building on top of atoms, Prudens's language also allows for literals, i.e., atoms or their
									negations. Negation is denoted by a single dash, <code>-</code>, preceeding an atom, as follows:
                                </p>
                                <ul>
									<li>positive literal (atom): <code>fatherOf(X, bob)</code></li>
									<li>negative literal (negated atom): <code>-fatherOf(X, bob)</code></li>
								</ul>
                                <h3>Rules & Policies</h3>
                                <p>
									Rules build up on literals and conceptually capture inferences of the form "If this then that".
									A rule may be expressed using the following syntax:
                                </p>
                                <ul>
									<li><code>Name :: h1, h2,..., hN implies head</code></li>
                                </ul>
                                <p>
									In the above:
								</p>
                                <ul>
									<li><code>Name</code> may be any string containing only alphanumeric characters and/or
									unedrscores;</li>
									<li><code>h1</code>, <code>h2</code>, <code>hN</code> and <code>head</code> may be
									literals of any form;</li>
									<li><code>::</code> and <code>implies</code> are reserved keywords 
									of Prudens's language.</li>
                                </ul>
                                <p>
									The part between <code>::</code> and <code>implies</code> is called the rule's <i>body</i>
									while the part after the <code>implies</code> keyword is called the rule's
									<i>head</i>.
                                </p>
                                <p>
									A <i>policy</i> is a list of multiple rules, separated by semicolons, <code>;</code>. Remark
									that within the same policy no two rules are allowed to share the same name.
                                </p>
                                <h3>Custom Predicates & Actions</h3>
                                <p>
									The above syntax corresponds to what one may say the language's "vanilla" version. However, over the
									course of Prudens's development, there has been a need for additional constructs. These are:
								</p>
								<ul>
									<li><i>Action atoms</i>, which are atoms whose name is preceeded by an explamation mark,
									<code>!</code> and may appear only as part of a rule's <b>head</b> and;</li>
									<li><i>Custom atoms</i>, which are atoms whose name is preceeded by a 
									question mark, <code>?</code>, and may appear only in a rule's <b>body</b>.</li>
								</ul>
								<p>
									Note that in any of the cases above, the negation dash, <code>-</code>, appears <b>before</b>
									any exlamation or question mark. Some examples are shown below:
                                </p>
                                <ul>
									<li><code>!stop</code></li>
									<li><code>!call(X)</code></li>
									<li><code>?includes(String, Substring)</code></li>
									<li><code>-?lessThan(X, 4)</code></li>
                                </ul>
                                <h3>Policy & Custom Code</h3>
                                <p>
									As discussed above, one may define their own custom atoms, which may be arbitrary JavaScript
									functions under the following restrictions:
                                </p>
                                <ul>
									<li>No calls to external libraries are allowed;</li>
									<li>No calls to other custom atoms are allowed and;</li>
									<li>No recursive calls are allowed, either.</li>
                                </ul>
                                <p>
									In order to distinguish between a policy's rules and any custom predicates defined, one may use
									the following two decorators:
								</p>
								<ul>
									<li><code>@KnowledgeBase</code></li>
									<li><code>@Code</code></li>
								</ul>
								<p>
									The first preceedes any code, be it policy-related or not, while the second separates a policy's 
									rules from any custom atoms. Given the above, the overall structure of a policy including
									custom code is as follows:
								</p>
								<pre>
									<code>@KnowledgeBase
										rule1;
										rule2;
										rule3;
										...
										
										@Code
										function foo(bar) {
											return bar;
										}
										
										function bar(foo) {
											return foo;
										}
									</code>
								</pre>
                            </div>
                            <div>
                                <h2>Reasoning</h2>
                                <p>
                                    Reasoning within Prudens relies on a prioritized variant of (grounded) forward chaining. 
                                    We shall explain the entire process using some examples, while, for more details, we suggest
                                    reading Section 4 from <a href="https://cognition.ouc.ac.cy/loizos/papers/Michael_2019_MachineCoaching.pdf">here</a>.
                                </p>
                                <h3>Simple Exceptions</h3>
                                <p>
									Let us consider the following simple policy:
								</p>
                                <pre>
									<code>R1 :: a implies x;
										R2 :: b, x implies y;
									</code>
                                </pre>
                                <p>
									As one would expect, given a context such as <code>a; b;</code> using the above policy one might
									infer that <code>x</code> as well as <code>y</code> hold. However, Prudens can handle more complex
									situations than that. For instance, consider the following policy, which contains two conflicting
									rules:
								</p>
                                <pre>
									<code>R1 :: a implies x;
										R2 :: a, b implies -x;
									</code>
                                </pre>
                                <p>
									Roughly, the above may be interpreted as follows:
								</p>
								<ul>
									<li>If <code>a</code> holds, then <code>x</code>;</li>
									<li>If, additionally, <code>b</code> holds as well, then <code>-x</code>.</li>
								</ul>
								<p>
									So, <code>R2</code> is an <b>exception</b> to <code>R1</code>, providing certain conditions 
									under which the general behavior dictated by <code>R1</code> should be violated.
								</p>
                                <h3>A More Complex Case</h3>
                                <p>
                                    Let us consider the following policy:
                                </p>
                                <pre>
                                    <code>R1 :: f(X, Y) implies g(X);
                                        R2 :: f(X, 1) implies -g(X);
                                    </code>
                                </pre>
                                <p>
                                    What would Prudens infer given a context such as <code>f(a,1); f(a,2);</code>?
                                    As with our previous examples, in this case, we have a setting where <code>R2</code>
                                    is an exception of <code>R1</code>. That is, whenever a literal of the form 
                                    <code>f(_,1)</code> appears in our context, then <code>R2</code> will be triggered.
                                    Since this is the case in our example as well, in our case Prudens will infer 
                                    <code>-g(a);</code>.
                                </p>
                                <p>
                                    However, removing <code>f(a,1)</code> from our context triggers only <code>R1</code>,
                                    so in this case <code>g(a)</code> would be inferred.
                                </p>
                            </div>
                    	</div>
                    </div>
                </div>
            <!-- </div> -->
        </div>
        <script type="text/javascript" src="navbar.js"></script>
        <script type="text/javascript" src="toc.js"></script>
        <script type="text/javascript" src="tocOnload.js"></script>
    </body>
</html>
