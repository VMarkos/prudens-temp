<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <link rel="stylesheet" type="text/css" href="style_1.css" media="screen"/>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
        <!-- <script type="text/javascript" src="parsers.js"></script>
        <script type="text/javascript" src="utils.js"></script>
        <script type="text/javascript" src="prudensUtils.js"></script>
        <script type="text/javascript" src="prudens.js"></script>
        <script type="text/javascript" src="abduction.js"></script> -->
        <title>
            Prudens
        </title>
    </head>
    <body>
        <div class="navbar-container">
            <div class="navbar-centering-container">
                <div class="hamburger-menu-container" onclick="burgerMenuDrop()">
                    <i id="menu-burger" class="fa fa-bars fa-2x"></i>
                </div>
                <div class="navbar-logo-container">
                    <a href="index.html">Prudens</a>
                </div>
                <div class="social-icons-container">
                    <a href="https://github.com/VMarkos/prudens-js"><i class="fa fa-github fa-2x"></i></a>
                </div>
            </div>
        </div>
        <div id="hamburger-menu" class="hamburger-menu hidden">
            <div class="menu-options-container">
                <div id="menu-options-container" class="menu-options-left-align">
                    <div class="menu-option">
                        <a href="index.html"><span><i class="fa fa-home"></i> Home</span></a>
                    </div>
                    <div class="menu-option">
                        <a href="prudens_web.html"><span><i class="fa fa-window-maximize"></i> Prudens Web</span></a>
                    </div>
                    <div class="menu-option">
                        <a href="prudens_api.html"><span><i class="fa fa-gears"></i> Prudens API</span></a>
                    </div>
                    <div class="menu-option">
                        <a href="docs.html"><span><i class="fa fa-book"></i> Learn Prudens</span></a>
                    </div>
                    <div class="menu-option">
                        <a href="research.html"><span><i class="fa fa-flask"></i> Research</span></a>
                    </div>
                </div>
            </div>
        </div>
        <div class="main-docs-container">
            <!-- <div class="cards-grid"> -->
                <div id="main-container" class="card-container no-animation">
                    <div class="docs-grid-container">
                    	<div class="toc-container">
                            <h2>Contents</h2>
                    		<ul id="toc">
                    		</ul>
                    	</div>
                    	<div class="docs-text-container">
                            <div>
                                <h2>Introduction</h2>
                                <p>
                                    Suppose you own one of these robot vacuum cleaners and that you can 
                                    interact with it in order to train it to behave as you wish. Moreover, 
                                    suppose that once you charge and set to action your robot vacuum cleaner 
                                    for the first time, you give it the following command:
                                </p>
                                <p class="quote-text">
                                    "Clean all the house every day at 7 PM!"
                                </p>
                                <p>
                                    Now, let us suppose that it is Sunday afternoon, 6:59 PM and that you are 
                                    relaxing. Suddenly, you hear an annoying sound coming from the living room; 
                                    it is the robot vacuum cleaner that has just started cleaning. It doesn't 
                                    take you long to realise that you should make some adjustments to your 
                                    cleaner's settings. Consequently, you get up, go to your living room and give 
                                    the following command to your tirelessly obedient cleaner:
                                </p>
                                <p class="quote-text">
                                    "Do not clean the house at 7 PM on Sundays! Instead, wait for me to tell you 
                                    when to start cleaning on Sundays!""
                                </p>
                                <p>
                                    In the above, you have just provided your automated cleaner with an exception 
                                    to its generic "Clean the house every day at 7 PM!" policy. Proceeding in 
                                    this way, you may find more circumstances in which you would like your 
                                    cleaner to deviate from its previous policy and temporarily adopt some 
                                    other behaviour.
                                </p>
                                <p>
                                    Situations like the one described above, where a human coaches a machine in 
                                    order to accomplish some certain tasks are captured by Machine Coaching (MC) 
                                    (see <a href="https://www.internetofus.eu/wp-content/uploads/sites/38/2021/05/Michael_2019_MachineCoaching.pdf">here</a> for more). In short, MC is an iterative 
                                    human-machine interaction process through which a human can transfer 
                                    knowledge to an agent who, in turn, acts based on it and returns 
                                    explanations in the form of arguments constructed from its 
                                    accumulated knowledge. Given the machine's feedback, the user may provide some 
                                    input in the form of some counter-argument, in order to update the agent's 
                                    knowledge. MC is implemented by Prudens, a tool that allows human users to 
                                    iteratively train their own agents, in a fashion similar to the one 
                                    described above.
                                </p>
                            </div>
                            <div>
                                <h2>The Language of Prudens</h2>
                                <p>
                                    Since MC offers a means of communication between humans and machines, it is natural that there should exist 
                                    some common language through which knowledge is transferred from the human end-user to the machine agent 
                                    and vice-versa. In this section we will describe the syntax and the semantics of this language as well as 
                                    provide numerous examples clarifying its features.
                                </p>
                                <h3>Predicates, variables and constants</h3>
                                <p>
                                    At some extent, Prudens's language shares several common features with prolog. 
                                    To begin with, Prudens's language allows for <em>predicates</em> to be used to denote relations between 
                                    entities of the universe. Syntactically, each predicate consists of two parts:
                                </p>
                                <ol>
                                    <li>
                                        its <em>name</em>, which starts with a lower-case letter of the English alphabet (a-z) which may be
                                        followed by any finite sequence of letters (a-z, A-Z), digits (0-9) and underscores (_), and;
                                    </li>
                                    <li>
                                        its <em>list of arguments</em>, which follows its name separated by no other 
                                        character and consists of a comma-separated list of arguments enclosed in left and 
                                        right parentheses.
                                    </li>
                                </ol>
                                <p>
                                    So, the syntactical form of a predicate is the following:
                                </p>
                                <pre><code>name(arg1,arg2,...,argn)</code></pre>
                                <p>
                                    We will refer to the (fixed) number, <math>n</math>, of arguments appearing in a predicate's arguments list 
                                    as the predicate's <em>arity</em> and we will also refer to a predicate of arity <math>n</math> as an 
                                    <math>n</math>-ary predicate.
                                </p>
                                <p>
                                    Regarding a predicate's arguments, they are restricted to be either <em>constants</em> or <em>variables</em> or 
                                    <em>valid mathematical expressions</em> &mdash; validity is decided based on 
                                    <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Math">ECMAScript 6 syntax</a>. 
                                    Constants are intended to be interpreted as specific entities of our universe while variables serve 
                                    as placeholders for constants. In Prudens's language, constants are represented by strings which 
                                    start with a lower-case letter (a-z) which may be followed by any finite sequence of letters 
                                    (a-z, A-Z), digits (0-9) and underscores (_) &mdash; exactly as with a predicate's name. 
                                    On the other hand, variables are represented by string which starts with an upper-case letter (A-Z) which 
                                    may again be followed by any finite sequence of letters (a-z, A-Z), digits (0-9) and 
                                    underscores (_). So, for instance, the following:
                                </p>
                                <pre><code>fatherOf(X,bob)</code></pre>
                                <p>
                                    is a binary predicate symbol, <code>fatherOf(&centerdot;,&centerdot;)</code>, with an arguments list consisting of a 
                                    variable, <code>X</code>, and a constant, <code>bob</code>. In case we interpret <code>fatherOf(X,Y)</code> 
                                    as "X is the father of Y" and assume that there exists some entity named Bob in our universe, 
                                    then the above may be interpreted as "Someone (<code>X</code>) is the father of Bob".
                                </p>
                                <p>
                                    We should remark at this point that a predicate's arity might well be zero. In this case, the predicate is 
                                    treated as a propositional symbol, being either true or false, regardless of the assignment of any 
                                    variables. Thus, Prudens's language supports both relational (first-order) as well as propositional policies, 
                                    as we shall see next.
                                </p>
                                <p>
                                    Proceeding with predicates' syntax, Prudens also allows for two types of special predicates:
                                </p>
                                <ul>
                                    <li>
                                        <em>action</em> predicates, whose name is preceded by an exclamation mark (!), such as <code>!brotherOf(X,bob)</code> and;
                                    </li>
                                    <li>
                                        <em>custom</em> predicates, whose name is preceded by a question mark (?), such as <code>?custom(X,Y,Z)</code>.
                                    </li>
                                </ul>
                                <p>
                                    Action predicates are used, if needed, to distinguish between actions that an agent should take and other 
                                    intermediate inferences. Custom predicates, on the other hand, are references to Boolean functions implemented 
                                    by the developer &mdash; more on this <a href="#defining-custom-predicates">here</a>.
                                </p>
                                <p>
                                    Lastly, we should mention at this point that Prudens's language has a special built-in predicate, 
                                    <code>?=(&centerdot;,&centerdot;)</code>, which serves as an extended unification and equality predicate. Prior to 
                                    explaining the various capabilities of <code>?=(&centerdot;,&centerdot;)</code>, we shall provide an example. Consider the 
                                    following policy:
                                </p>
                                <pre><code>@KnowledgeBase
                                    R1 :: siblingOf(bob,Y), ?=(Y,alice) implies olderSibling(Y);
                                </code></pre>
                                <p>Given the following context:</p>
                                <pre><code>siblingOf(bob, charlie); siblingOf(bob, alice); siblingOf(bob, david);</code></pre>
                                <p>
                                    we may infer: <code>olderSibling(alice)</code>. Essentially, <code>?=(&centerdot;,&centerdot;)</code> checks 
                                    whether its two arguments unify and, if so, it unifies them.
                                </p>
                                <p>
                                    As one may suspect, <code>?=(&centerdot;,&centerdot;)</code> may also be negated. 
                                    So, if instead of the above policy we use the following one:
                                </p>
                                <pre><code>@KnowledgeBase
                                    R1 :: siblingOf(bob,Y), -?=(Y,alice) implies brotherOf(bob, Y);
                                </code></pre>
                                <p>
                                    using the same context we infer:
                                </p>
                                <pre><code>brotherOf(bob, charlie); brotherOf(bob, david);</code></pre>
                                <p>
                                    We shall remark that any variable mentioned within the arguments of the equality predicate should be also 
                                    referenced by at least one other predicate in the <em>same rule's body</em> or as a free variable within 
                                    the context &mdash; for more, see <a href="#ungrounded-contexts">here</a>. 
                                    Lastly, <code>?=(&centerdot;,&centerdot;)</code> may be used to perform mathematical operations, 
                                    as we discuss <a href="#mathematical-operations">here</a>.
                                </p>
                                <h3>Policies, contexts and inference</h3>
                                <p>
                                    All predicates may be negated by appending a dash (-) in front of them. A <em>literal</em> is either a 
                                    predicate or its negation. Two literals that stem from the same predicate but have conflicting signs 
                                    (i.e., the one is the predicate itself while the other is its negation) are <em>conflicting</em>. 
                                    Literals, as we shall see, are the building blocks of policies in Prudens. 
                                    Examples of literals are the following ones:
                                </p>
                                <pre><code>fatherOf(X,bob)</code>, <code>-fatherOf(Y,alice)</code></pre>
                                <p>
                                    Utilizing literals, rules are defined as a string of the following form:
                                </p>
                                <pre><code>name :: body implies head;</code></pre>
                                <p>
                                    So, each rules consists of:
                                </p>
                                <ol>
                                    <li>
                                        a <em>name</em>, which is a string separated by <code>::</code> from the rule's main part;
                                    </li>
                                    <li>
                                        a <em>body</em>, which is a comma-separated list of literals and;
                                    </li>
                                    <li>
                                        a <em>head</em>, which is a single literal separated from the rule's body by the <em>implies</em> keyword.
                                    </li>
                                </ol>
                                <p>
                                    Intuitively, each rule is interpreted as an IF-body-THEN-head inference. So, for instance, 
                                    the following rule, where all predicates have the obviously intended interpretation is interpreted as 
                                    "Any two people having the same mother are siblings":
                                </p>
                                <pre><code>R1 ::\ motherOf(X,Z), motherOf(Y,Z) implies siblings(X,Y);</code></pre>
                                <p>
                                    Two rules with conflicting literals as heads are <em>conflicting</em>. A policy is a set of rules (conflicting or 
                                    not) alongside an order relation defined over all pairs of conflicting rules. By default, 
                                    Prudens assumes that priorities are determined by the order of appearance of rules in the policy 
                                    (the later a rule appears, the higher its priority over conflicting ones). For instance, the following is an 
                                    example of a policy:
                                </p>
                                <pre><code>@KnowledgeBase}
                                    R1 :: bird(X) implies flies(X);
                                    R2 :: penguin(X) implies bird(X);
                                    R3 :: penguin(X) implies -flies(X);
                                </code></pre>
                                <p>
                                    where <code>R3</code> is of higher priority than <code>R1</code>, since it appears later on in the policy. 
                                    The <code>@KnowledgeBase</code> decorator above all rules is a keyword of Prudens's language, used to 
                                    indicate where the policy's rules start.
                                </p>
                                <p>
                                    Policies, intuitively, are an abstraction of the agent's behavior under several circumstances. These 
                                    circumstances within MC are called <em>contexts</em> and are actually sets of pairwise non conflicting 
                                    literals. So, for instance, the following is a context:
                                </p>
                                <pre><code>penguin(bob);</code></pre>
                                <p>
                                    According to it, an entity of our universe, <code>bob</code>, is a penguin. Given the above policy, 
                                    we can infer various things about <code>bob</code>. Namely:
                                </p>
                                <ol>
                                    <li>
                                        Initially, only knowing that <code>bob</code> is a penguin, we infer from rule <code>R2</code> that 
                                        <code>bob</code> is a bird and from <code>R3</code> that it cannot fly.
                                    </li>
                                    <li>
                                        Knowing now that <code>bob</code> is also a bird, we could infer, through <code>R1</code>, that is can fly. 
                                        However, since <code>R3</code> is of higher priority than <code>R1</code>, we do not infer that 
                                        <code>bob</code> flies.
                                    </li>
                                </ol>
                                <p>
                                    So, eventually, given the above context and policy, we infer that <code>bob</code> is a bird that cannot fly.
                                </p>
                                <h3>Defining custom predicates</h3>
                                <p>
                                    As we have already discussed <a href="#predicates--variables-and-constants">here</a>, one may also define their own custom 
                                    predicates. Such predicates are JavaScript Boolean functions, and are declared under the 
                                    <code>@Code</code> decorator, as in the example shown below:
                                </p>
                                <pre><code>@KnowledgeBase
                                    R1 ::\ heightOf(X, H), ?isWithinLimits(H) implies accept(X);
                                    
                                    @Code
                                    function isWithinLimits(x) {
                                    &nbsp;&nbsp;&nbsp;&nbsp;const xFloat = parseFloat(x);
                                    &nbsp;&nbsp;&nbsp;&nbsp;return xFloat > 170 \&\& xFloat &lt; 190;
                                    }
                                </code></pre>
                                <p>
                                    There are several points that we should highlight 
                                    regarding the syntax of custom predicates:
                                </p>
                                <ol>
                                    <li>
                                        <code>@KnowledgeBase</code> should always appear above
                                        <code>@Code</code>.
                                    </li>
                                    <li>
                                        When references in a policy rule, under the <code>@KnowledgeBase</code> decorator, the custom 
                                        predicate's name should be preceded by a 
                                        <code>?</code>. On the contrary, this is not the case when the custom predicate itself is declared as 
                                        a JavaScript function under the <code>@Code</code> decorator, since this would be invalid JavaScript syntax.
                                    </li>
                                    <li>
                                        All code following the <code>@Code</code> decorator should be valid under the 
                                        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">ECMAScript 6 specifications</a>.
                                    </li>
                                    <li>
                                        All JavaScript functions defining custom predicates should return some Boolean value. 
                                        If this is not the case, any returned value is interpreted as a Boolean value according to 
                                        ECMAScript 6 specifications &mdash; more on what is <code>true</code> in ECMAScript 6 
                                        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean">here</a>.
                                    </li>
                                    <li>
                                        No function calls are allowed within any of the functions defined under the <code>@Code</code> decorator. 
                                        That is, any function defined below <code>@Code</code> should correspond to some custom predicate, otherwise 
                                        it is cannot be utilized as an auxiliary function.
                                    </li>
                                    <li>
                                        All arguments in a function defined under <code>@Code</code> are considered to be <em>strings</em>. 
                                        That is, in case a predicate's arguments are intended to be floats, you need to use <code>parseFloat</code> as 
                                        above, or <code>parseInt</code>, in case they are supposed to be integers. 
                                        More on these two functions may be found <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseFloat">here</a> 
                                        and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt">here</a> respectively.
                                    </li>
                                </ol>
                                <h3>Mathematical operations</h3>
                                <p>
                                    Prudens supports mathematical operations under certain conditions. To begin with, as mentioned 
                                    in <a href="#policies--contexts-and-inference">here</a>, <code>?=(&centerdot;,&centerdot;)</code> may be used 
                                    for mathematical operations 
                                    within its arguments, provided that they do not invoke any variables that remain unassigned 
                                    <em>once the rule is triggered</em>. So, a rule like:
                                </p>
                                <pre><code>R1 :: f(X), ?=(Y, X+3) implies g(Y);</code></pre>
                                <p>
                                    with a context containing <code>f(2)</code> would infer <code>g(5)</code>. However, using:
                                </p>
                                <pre><code>R2 :: f(X), ?=(Y-3, X) implies g(Y);</code></pre>
                                <p>
                                    with the same context would not, since there is no value assigned to 
                                    <code>Y</code> by the time the rule is invoked. Any mathematical expressions within 
                                    <code>?=(&centerdot;,&centerdot;)</code> should adhere to the usual 
                                    <a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/First_steps/Math">ECMAScript 6 
                                    syntax</a>.
                                </p>
                                <p>
                                    Prudens's language also allows for math operations to be executed within any predicate, 
                                    given the restrictions mentioned above, about unassigned variables. Similarly to the equality 
                                    predicate, numerical operations may not be used in head literals. For instance, the following rule:
                                </p>
                                <pre><code>R1 ::\ f(X, 2*X) implies double;</code></pre>
                                <p>
                                    given a context containing <code>f(2,4)</code> infers <code>double</code>. 
                                    An equivalent rule, avoiding within-predicate operations, would be:
                                </p>
                                <pre><code>R2 ::\ f(X, Y), ?=(Y, 2*X) implies double;</code></pre>
                                <p>
                                    which, however, introduces an additional variable, <code>Y</code>, and leads to slightly slower 
                                    processing time. Thus, whenever possible, within-predicate math operations should be 
                                    preferred against <code>?=(&centerdot;,&centerdot;)</code>.
                                </p>
                                <h3>Custom Priorities and Dilemmas</h3>
                                <p>
                                    Rule priorities are by default determined by order of appearance within a policy. 
                                    However, one may define custom priorities as well. In fact, this can be done in two ways: 
                                    programmatically, by providing a priority function as an optional argument to the Prudens's 
                                    core reasoning function &mdash; for more, see <a href="https://github.com/VMarkos/prudens-js/releases/tag/v0.8.3">here</a> &mdash; 
                                    and; syntactically, by providing priorities explicitly within each rule's declaration. 
                                    Regarding syntactic priority manipulation, the language's "vanilla" rule syntax is extended to 
                                    allow for priorities to be declared through integers following a rule's head, 
                                    separated by a <code>|</code>, as follows:
                                </p>
                                <pre><code>name ::\ body implies head | priority;</code></pre>
                                <p>
                                    There, numbers indicate priority, with negative values being allowed as well. So, given a context 
                                    containing <code>a; b;</code>, the following policy would yield <code>z</code>, since <code>R1</code> is preferred 
                                    over <code>R2</code>.
                                </p>
                                <pre><code>@KnowledgeBase
                                    R1 :: a implies z | 1;
                                    R2 :: b implies -z | 0;
                                </code></pre>
                                <p>
                                    Naturally, allowing for custom priorities, there might be cases where two rules are incomparable, 
                                    either because no priority between them has been explicitly determined or because they are of the same 
                                    priority, as with the following policy:
                                </p>
                                <pre><code>@KnowledgeBase
                                    R1 :: a implies z | 1;
                                    R2 :: b implies -z | 1;
                                </code></pre>
                                <p>
                                    Such cases are called <em>dilemmas</em>. Since there is no clear way to resolve a 
                                    dilemma, the reasoning engine abstains from making a decision, ignoring both rules and proceeding 
                                    with the reasoning process. Any dilemmas encountered throughout a reasoning cycle are noted 
                                    and returned separately from the rest inferences.
                                </p>
                                <h3>Ungrounded Contexts</h3>
                                <p>
                                    Literals in a context may be partially or even totally ungrounded. That is, a context may well contain 
                                    literals like <code>f(Y)</code>, even if <code>Y</code> is a free variable. In any such 
                                    case, variables propagate throughout inferences, unifying with other variables whenever it 
                                    makes sense. For instance consider the following policy:
                                </p>
                                <pre><code>@KnowledgeBase
                                    R1 :: f(A), g(X) implies h(X,A);
                                </code></pre>
                                <p>
                                    Using the left one with a context containing <code>f(Y); g(3);</code> one infers
                                    <code>h(3,Y)</code>. Note at this point that any unassigned context variables are not 
                                    distinguished from policy variables in case they bear the same name. So, 
                                    having <code>f(X)</code> in our context instead of <code>f(Y)</code>, would lead to 
                                    inferring <code>h(3,3)</code>, since <code>X</code> is a variable that also appears 
                                    in <code>R1</code>, substituted by <code>3</code>. Using a context containing 
                                    <code>f(Y)</code> with the policy shown below, this time, we could infer <code>z(3)</code>.
                                </p>
                                <pre><code>@KnowledgeBase
                                    R1 :: f(A), g(X) implies h(X,A);
                                    R2 :: h(X,b) implies z(X);
                                </code></pre>
                                <h3>Extended Conflict Semantics</h3>
                                <p>
                                    In the vanilla version of the language, two literals are considered conflicting in case they 
                                    stem from the same predicate but have opposite signs. Prudens's language, however, 
                                    also allows for rules that determine broader conflicts between arbitrary predicates. Such rules are 
                                    called <em>compatibility constraints</em> and adhere to the following syntax:
                                </p>
                                <pre><code>ruleName ::\ pred1 \# pred2;</code></pre>
                                <p>
                                    So, for instance, using the policy shown below and a context containing 
                                    <code>a; b;</code>, one infers <code>y</code>, since <code>C1</code> 
                                    declares <code>y</code> and <code>x</code> as conflicting literals.
                                </p>
                                <pre><code>@KnowledgeBase
                                    R1 :: a implies x;
                                    R2 :: b implies y;
                                    
                                    C1 :: x \# y;
                                </code></pre>
                                <p>
                                    Note at this point that there are assumed no priorities between compatibility constraints, 
                                    opposed to what is the case with the rest rules in a policy.
                                </p>
                            </div>
                            <div>
                                <h2>Reasoning</h2>
                                <p>
                                    Having presented the language of Prudens in detail, we shall now shed more light on 
                                    how Prudens "thinks".
                                </p>
                                <h3>Simple Forward Reasoning</h3>
                                <p>
                                    The ground upon which Prudens's reasoning algorithm relies is a simple forward reasoning 
                                    process. For instance, let us consider the following policy:
                                </p>
                                <pre><code>@KnowledgeBase
                                    R1 :: a implies x;
                                    R2 :: b, c implies y;
                                    R3 :: x, y implies z;
                                </code></pre>
                                <p>
                                    Given a context containing <code>a; b; c;</code>, we can infer all 
                                    <code>x</code>, <code>y</code> and <code>z</code>. 
                                    The exact way this is conducted is presented below:
                                </p>
                                <ul>
                                    <li>
                                        Consider a list, &ell;, initially containing all facts that are contained in our context; 
                                        namely, <code>a</code>, <code>b</code> and <code>c</code>;
                                    </li>
                                    <li>
                                        Given these facts, rules <code>R1</code> and <code>R2</code> fire, allowing us to infer 
                                        <code>x</code> and <code>y</code> and, consequently, add them to &ell;;
                                    </li>
                                    <li>
                                        Now, knowing <code>x</code> and <code>y</code>, rule <code>R3</code> fires as well, allowing us 
                                        to infer <code>z</code> and append it to &ell;;
                                    </li>
                                    <li>
                                        Given that no other inferences may be drawn given our currently known facts and rules, the process terminates.
                                    </li>
                                </ul>
                                <p>
                                    Essentially, we apply all known and applicable rules, trying to 
                                    infer new facts and repeat until nothing new may be inferred. 
                                </p>
                                <p>
                                    While all rules in the above example were purely propositional, the same applies to relational 
                                    policies like the one shown below:
                                </p>
                                <pre><code>@KnowledgeBase
                                    R1 :: parentOf(X, Z), parentOf(Y, Z) implies siblings(X, Y);
                                    R2 :: siblings(X, Y), ageOf(X, Age1), ageOf(Y, Age2), ?=(Age1, Age2) implies twins(X, Y);
                                </code></pre>
                                <p>
                                    Given a context containing the following:
                                </p>
                                <pre><code>parentOf(alice,charlie); parentOf(bob,charlie); ageOf(alice,23), ageOf(bob,23);
                                </code></pre>
                                <p>
                                    one may infer the following:
                                </p>
                                <pre><code>siblings(alice,alice); siblings(alice,bob); siblings(bob,alice); siblings(bob,bob); twins(alice,alice); twins(alice,bob); twins(bob,alice); twins(bob,bob);</code></pre>
                                <p>
                                    Quite messy, right? As you may observe, there are several quite trivial facts that Prudens has inferred above, like:
                                </p>
                                <pre><code>siblings(alice,alice); siblings(bob,bob); twins(alice,alice); twins(bob,bob);</code></pre>
                                <p>
                                    To shed more light on it, we shall expose some of Prudens's internal reasoning:
                                </p>
                                <ul>
                                    <li>
                                        At first, since we know <code>parentOf(alice, charlie)</code> and <code>parentOf(bob, charlie)</code>, 
                                        rule <code>R1</code> fires, so, all possible substitutions to its body's 
                                        variables, <code>X</code>, <code>Y</code>, and <code>Z</code>, are generated, by unifying all 
                                        body literals with those in the context:
                                        <ul>
                                            <li>
                                                <code>X</code>&rightarrow;<code>alice</code>, <code>Y</code>&rightarrow;<code>alice</code>, <code>Z</code>&rightarrow;<code>charlie</code>;
                                            </li>
                                            <li>
                                                <code>X</code>&rightarrow;<code>alice</code>, <code>Y</code>&rightarrow;<code>bob</code>, <code>Z</code>&rightarrow;<code>charlie</code>;
                                            </li>
                                            <li>
                                                <code>X</code>&rightarrow;<code>bob</code>, <code>Y</code>&rightarrow;<code>alice</code>, <code>Z</code>&rightarrow;<code>charlie</code>;
                                            </li>
                                            <li>
                                                <code>X</code>&rightarrow;<code>bob</code>, <code>Y</code>&rightarrow;<code>bob</code>, <code>Z</code>&rightarrow;<code>charlie</code>;
                                            </li>
                                        </ul>
                                    </li>
                                    <li>
                                        For each one of the above substitutions, the corresponding inference is drawn:
                                        <ul>
                                            <li>
                                                <code>siblings(alice, alice)</code>;
                                            </li>
                                            <li>
                                                <code>siblings(alice, bob)</code>;
                                            </li>
                                            <li>
                                                <code>siblings(bob, alice)</code>;
                                            </li>
                                            <li>
                                                <code>siblings(bob, bob)</code>;
                                            </li>
                                        </ul>
                                    </li>
                                </ul>
                                <p>
                                    Similarly, Prudens proceeds with the rest of the process, inferring the rest of the facts presented above.
                                </p>
                                <h3>Introducing Exceptions</h3>
                                <p>
                                    So far, we have presented some simple examples of forward reasoning, were from some facts, given a set of 
                                    rules, we infer some new facts and then we iterate until we have exhausted what we could learn from the 
                                    above. However, what makes Prudens really powerful, is its ability to handle conflicts between rules. 
                                    Consider, for example, the following policy:
                                </p>
                                <pre><code>@KnowledgeBase
                                    R1 :: a implies z;
                                    R2 :: a, b implies -z;
                                </code></pre>
                                <p>
                                    Given a context containing only <code>a</code>, rule <code>R1</code> fires, yielding 
                                    <code>z</code>. However, if our context also contained <code>b</code>, then both 
                                    <code>R1</code> and <code>R2</code> would fire, inferring <code>z</code> and 
                                    <code>-z</code> at the same time. In this case, <code>-z</code> would survive and 
                                    <code>z</code> would be rejected, since Prudens silently assumes that the later a rule 
                                    appears within the same policy, the higher its priority in case of conflicts.
                                </p>
                                <p>
                                    As a more complex example, consider the following policy:
                                </p>
                                <pre><code>@KnowledgeBase
                                    R1 :: a implies x;
                                    R2 :: a, b implies y;
                                    R3 :: a, x implies -y;
                                </code></pre>
                                <p>
                                    In this case, a context containing <code>a></code> and <code>b</code> would lead us infer <code>x</code> and <code>-y</code>, as follows:
                                </p>
                                <ul>
                                    <li>
                                        At first, knowing <code>a</code> and <code>b</code>, <code>R1</code> and <code>R2</code> fire, allowing us to infer <code>x</code> and <code>y</code>;
                                    </li>
                                    <li>
                                        Knowing <code>x</code>, rule <code>R3</code> fires, leading to <code>-y</code>, which conflicts with <code>y</code>. This conflict 
                                        is resolved by preferring <code>-y</code> over <code>y</code>, since the former was 
                                        inferred by <code>R3</code>, which is of higher priority than <code>R2</code>.
                                    </li>
                                    <li>
                                        Having inferred <code>x</code> and <code>-y</code>, nothing more may be inferred, 
                                        so the process terminates.
                                    </li>
                                </ul>
                                <p>
                                    Let us also consider a first-order policy containing conflicts:
                                </p>
                                <pre><code>@KnowledgeBase
                                    R1 :: f(X) implies z(X);
                                    R2 :: f(X), g(X, 4) implies -z(X);
                                </code></pre>
                                <p>
                                    In this case, having a context containing <code>f(1); f(2); g(1,4);</code> we might 
                                    infer <code>z(2)</code> and <code>-z(1)</code>, since:
                                </p>
                                <ul>
                                    <li>
                                        <code>f(1)</code> and <code>g(1,4)</code> trigger both <code>R1</code> and <code>R2</code> 
                                        and <code>R2</code> is of higher priority than <code>R1</code> but;
                                    </li>
                                    <li>
                                        <code>f(2)</code> triggers <code>R1</code> and there is nothing like <code>g(2,4)</code> 
                                        to trigger <code>R2</code> in this case.
                                    </li>
                                </ul>
                                <h3>Dilemmas</h3>
                                <p>
                                    So far, we have referred to dilemmas as those cases when no priority has been determined between 
                                    two conflicting rules. In such cases, Prudens abstains from making any 
                                    inference, noting down the dilemma and proceeding with the rest of the reasoning process. 
                                    To shed more light on that, let us revisit a policy we used above:
                                </p>
                                <pre><code>@KnowledgeBase
                                    R1 :: a implies x;
                                    R2 :: a, b implies y | 1;
                                    R3 :: a, x implies -y | 1;
                                </code></pre>
                                <p>
                                    We have explicitly stated that <code>R2</code> and <code>R3</code> are of the same priority. 
                                    So, with a context containing <code>a</code> and <code>b</code>, we get nothing more than <code>x</code> 
                                    in this case. Indeed, this time, the reasoning process goes as follows:
                                </p>
                                <ul>
                                    <li>
                                        At first, knowing <code>a</code> and <code>b</code>, <code>R1</code> and <code>R2</code> fire, allowing 
                                        us to infer <code>x</code> and <code>y</code>;
                                    </li>
                                    <li>
                                        Knowing <code>x</code>, rule <code>R3</code> fires, leading to <code>-y</code>, which conflicts 
                                        with <code>y</code>. This conflict <em>remains unresolved</em>, since <code>R2</code> and <code>R3</code> 
                                        are of the same priority, so <code>y</code> is removed from the known facts list;
                                    </li>
                                    <li>
                                        Since there is nothing more to infer, the algorithm terminates.
                                    </li>
                                </ul>
                            </div>
                    	</div>
                    </div>
                </div>
            <!-- </div> -->
        </div>
        <script type="text/javascript" src="navbar.js"></script>
        <script type="text/javascript" src="toc.js"></script>
        <script type="text/javascript" src="tocOnload.js"></script>
    </body>
</html>
